# 插入排序

## 直接插入排序（Straight Insertion Sort）

直接插入排序是简单直观的排序方法，将一个记录插入到已排好的有序表中，从而得到一个新的、记录数增1的有序表。

通过构建有序序列，对未排序数据，在已排序数据中从前向后扫描，找到相应位置并插入。采用in-place排序（只需要用到O(1)的额外空间的排序）。在从后向前扫描的过程中，需要反复把已排序的元素向后移动。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Insertion-sort-example-300px.gif/220px-Insertion-sort-example-300px.gif)

默认第一个元素已排序，从第二位开始遍历，外层循环遍历需要插入的元素，遍历至最后一个元素停止，内层循环用于确定插入元素在已排序数组中的位置，同时将大于该元素的数组后移；最后将元素插入。

### 具体实现

```java
 void sort(int arr[]){
//        for(int i = 1; i < arr.length; ++i){
//            int temp = arr[i];
//            int j = i - 1;
//
//            while( j >= 0 && arr[j] > temp) {
//                arr[j + 1] = arr[j];
//                j--;
//            }
//            arr[j + 1] = temp;
//        }
        for(int i = 1; i < arr.length; ++i){
            int temp = arr[i];
            int j;
            for(j = i - 1; j >= 0 && arr[j] > temp; --j)
                arr[j + 1] = arr[j];
            arr[++j] = temp;
        }
    }
```

### 算法效率

边界情况：最好的情况是序列已经升序排列（如果算法目标是把n个元素升序），只需比较n-1次即可。最坏情况为元素降序，需要进行`1 / 2 * n *  (n - 1)`次比较。平均来说，插入排序算法复杂度为 O(n^2)。

插入排序不适合数据量较大的排序应用，如果需要排序的数据量很小，插入排序还是个很不错的选择。

## 折半插入排序（Binary Insertion Sort）

对插入排序的改进，需要从比较次数和移动次数两处着手。折半插入从减少比较次数着手，而移动次数不变。折半插入排序花费可以将时间复杂度从 O(n^2)降为O(log n)，依旧是一个稳定的排序算法。

~~~java
    void binarySearch(int arr[]) {
        for (int i = 1; i < arr.length; ++i) {
            int temp = arr[i];
            int low = 0;
            int high = i - 1;
          	//折半插入核心
            while (low <= high) {
                int m = low + high / 2;
                if (arr[m] > temp)
                    high = m - 1;
                else
                    low = m + 1;
            }
          	//将数据后移然后插入
            for (int j = i - 1; j >= low; --j) {
                arr[j + 1] = arr[j];
            }
            arr[low] = temp;
        }
    }
~~~

## 2-路插入排序（Two-way Insertion Sort）

因为折半插入排序不改变移动次数，因此2-路插入排序在折半插入排序的基础上进行改进，用于较少排序过程中的移动次数，但是需要额外n个的辅助空间。

2-路插入排序需要创建一个和存储记录数量大小相同的数组b，将原数组的第一个记录添加到合适的位置，假设为b[0]，从原数组的第二个元素开始进行比较，比较过程一共有三种情况：插入元素比最小的元素小，插入元素比最大元素大，插入元素在两者之间，最后一种情况则需要移动元素。

### 实现

```java
  public void twoWayInsertionSort(int arr[], int brr[]){
        int length = arr.length;
        int first =0, last = 0;//point to the greater one and tiny one.
        brr[0] = arr[0];
        for(int i = 1; i < length; ++i){
            //greater than the biggest one
            if(arr[i] >= brr[last]){
                brr[++last] = arr[i];
            }
            else if(arr[i] <= brr[first]){
                first = (first - 1 + length) % length;
                brr[first] = arr[i];
            }
            else{
						//int j = (last - 1 + length) % length;
                int j = last;
                while(brr[j] > arr[i]){
                    brr[(j + 1) % length] = brr[j];//move back element
                    j = (j - 1 + length) % length;//update point
                }
                brr[(j + 1) % length] = arr[i];
                last++;
            }
            System.out.println("First is " + first + "Last is " + last);
        }
        //copy back to the array
        for(int i = 0; i < length; ++i){
            arr[i] = brr[(first + i) % length];
        }
    }

```

### 效率

在2-路插入排序中，移动次数约为n^2/8，仅仅减少了排序的移动次数，但不能绝对避免移动，时间复杂度依旧为O(n ^ 2)。

## * 表插入排序 *

需要从根本上避免移动，则需要对存储结构进行改变，将结构改为**静态链表**作为待排记录序列的存储结构。

对于一个有序的循环链表，插入新元素，只需修改后继指针的指向，在这个过程中，我们不需要移动或交换元素。

顺着指针指向对元素进行调整，能够做到物理有序。

1. 创建新的静态链表结构体，封装值和指针。同时设置一个头节点，值存储不小于原序列最大值的值。
2. 对链表进行初始化
3. 将后续节点一次插入循环链表中，调整节点指针指向，使其有序。

```java
package Sort;

public class TableInsertionSort {
    public static Node init() {
        int[] a = {49, 38, 65, 97, 76, 13, 27, 49};
        Node head = new Node();
        Node p = head;
        for (int i = 0; i < a.length; i++) {
            Node node = new Node();
            node.setKey(a[i]);
            p.setNode(node);
            p = node;
        }
        return head;
    }

    public static void sort(Node list) {
        Node pre, now, p, q, head;
        head = list;
        pre = list.getNode();
        now = pre.getNode();
        while (now != null) {
            q = head;
            p = q.getNode();
            while (p != now && p.getKey() <= now.getKey()) {
                q = p;
                p = p.getNode();
            }
            if (p == now) {
                pre = pre.getNode();
                now = pre.getNode();
                continue;
            }
            pre.setNode(now.getNode());
            q.setNode(now);
            now.setNode(p);
            now = pre.getNode();
        }
    }

    public static void printList(Node head) {
        Node p = head.getNode();
        while (p != null) {
            System.out.print(p.getKey() + " ");
            p = p.getNode();
        }
    }

    public static void main(String agrs[]) {
        Node list = init();
        sort(list);
        printList(list);
    }

    //set Node class
     static class Node {
        private int key;
        private Node node;

        public Node() {

        }

        public Node(int key, Node node) {
            this.key = key;
            this.node = node;
        }

        public int getKey() {
            return key;
        }

        public void setKey(int key) {
            this.key = key;
        }

        public Node getNode() {
            return node;
        }

        public void setNode(Node node) {
            this.node = node;
        }
    }
}

```

 效率：

元素推动次数为0，算法比较次数与直接插入排序算法比较次数同级，平均时间复杂度为O(n ^ 2)。每个元素增加一个指向下一个节点的指针，辅助空间O(n)，且算法**稳定**。

## 希尔排序（Shell Sort）

希尔排序也称“缩小增量排序”（Diminishing Increment Sort），是简单的插入排序经过改进后一个更高效的版本。

基本思想：把记录按下标的一定增量分组【将记录序列进行分割】，然后对每组进行插入排序，随着增量的减少，每组包含的关键字越多，当增量变为1时，对全体文件进行一次直接插入排序。

希尔排序通过分组并进行插入排序的方式对数组进行排序，从宏观上看数组逐渐有序，因为数组基本有序，所以在进行直接插入排序的过程中很少出现排序效率最低的情况，多数情况只需要对数据进行微调，从而降低了时间复杂度。

基于插入排序的两点性质：

1. 插入排序对几乎排好的数据操作效率很高，可以达到线性排序效率。
2. 但插入排序一般来说是低效的，因为每次只能移动一位数据。

一般我们会选择增量gap为length/2，缩小增量继续以gap/2的形式进行。希尔排序的增量序列选择涉及数学上的难题，不做讨论。

~~~java
  //交换
    public void sort(int arr[]) {
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                //每次都与相隔gap位的值进行比较
                int j = i;
                while (j - gap >= 0 && arr[j] < arr[j - gap]) {
                    //swap the element
                    swap(arr, j, j - gap);
                    j -= gap;
                }
            }
        }
    }

    //移动
    public void sortMove(int arr[]) {
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                //每次都与相隔gap位的值进行比较
                int j = i;
                int temp = arr[i];
                while (j - gap >= 0 && arr[j] < arr[j - gap]) {
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                arr[j] =temp;
            }
        }
    }
~~~

### 效率

希尔排序的效率收gap值的影响，选择不同的gap值能够得到不同的时间效率，一般建议gap取n/2，这样可以比多数O(n ^ 2)的算法更好，但仍可以减少平均时间和最差时间的空间。



