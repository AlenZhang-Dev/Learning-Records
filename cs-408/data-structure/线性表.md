# 数据结构

[toc]

## 线性表

### 2.2.3 综合应用题

#### 1. 删除数组中最小值

从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删除的元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。

```c
bool DeleteMin(sqList &L, ElemType &value) {
		if(L.length == 0)
      	return false;
  	//find the smallest number.
  	int Value = L.data[0];
  	int index = 0; //record the index of array.
  	for(int i = 1; i < L.length; i++) {
      	if(L.data[i] < minValue) {
          	Value = L.data[i];
         		index = i;
        }
    }
  	L.data[i] = L.data[L.length - 1];
  	L.length--;
  	return true;
}
```

#### 2. 逆置数组元素

设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。

```c
void Reverse(sqList &L) {
  	int low = 0, high = L.length - 1;
  	while(low < high) {
       	//swap
      	L.data[low] = L.data[low] ^ L.data[high];
      	L.data[high] = L.data[low] ^ L.data[high];
        L.data[low] = L.data[low] ^ L.data[high];
    }
}
```

#### 3. 删除数组中元素值为x的元素

对长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。

通过元素移动的方式进行。

```c
//k标记不为x的元素数量。
void Delete_x(sqList &L, Elemtype x){
  	int k = 0;
  	for(i = 0; i < L.length; i++){
      	if(L.data[i] != x){
          	L.data[k] = L.data[i];
      			k++;
        }
    }
  	L.length = k;
}
//k标记x的元素数量
void Delete_x(sqlList &L, Elemtype x){
		int k = 0;
  	for(i = 0; i < Length; i++){
      	if(L.data[i] == x)
           k++;
				else
           L.data[i - k] - L.data[i];
    }
  	L.length = L.length - k;
}
```

#### 4. 删除有序表中[s,t]之间的元素

从<u>有序顺序表</u>中删除其值在给定s与t之间（要求s<t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。

```c
void Delete_s_t(sqList &L, ElemType s, ElemType t){
  	if(s >= t || L.length <= 0)
      	return false;
  	int low, high;
  	//find the first element which is equal or larger than s.
  	for(low = 0; low < L.length && L.data[low] < s; low++)
   	if(low > L.length)
      	return false;
    //find the first element which is equal or smaller than s.
    for(high = L.length - 1; high >= low && L.data[high] > s; high--)
    //move the element.
    for( ;high < L.length; high++, low++)
  			L.data[low] = L.data[high];
  	L.length = low;
  	return true;
}
```

#### 10. 旋转数组问题

设将`n`(n > 1)个整数存放到一维数组R中。设计一个在时间和空间两方面尽可能高效的算法。将R中保存的序列循环右移`k`(0<k<n)个位置。

经典的旋转数组问题。有多种方式进行解决，尽可能找到最优算法。

需要注意的一个问题：`p > numsSize`怎么处理?   =>   `p %= numsSize;`

**双重遍历**

数组向右移动`k`位，每次将数组最后一个元素取出，从`numSize-1`位开始，依次将数组后移，最后将取出元素放入数组头部。完成一次移动，共进行`k`次移动。

```c
void rotate(int* nums, int numsSize, int k){
    k %= numsSize;
    for(int i = 0; i < k; i++){
        int temp = nums[numsSize - 1];
        for(int j = numsSize - 1; j > 0; j--){
            nums[j] = nums[j - 1];
        }
        nums[0] = temp;
    }
}
```

时间复杂度O(kn) 接近 $n^{2}$ [复杂度过高]。空间复杂度O(1)。

**交换**

通过交换的方式将数组下标为`[len - k, len - 1]`位的数字移动到前`[0, k- 1]`，每次loop会将前`k`位元素放到正确的位置。需要继续对剩下`n-k`部分进行排序，`n`位未排序的数组长度，需要随时更新。总排序次数$\left \lceil \frac{len - k}{k}  \right \rceil$ 次，数组移动次数为常数时间。

```c
void rotate(int* nums, int numsSize, int k){
    int n = numsSize;
    k %= n;
    for(int index = 0; index < numsSize && k != 0; n -= k, index += k, k %= n)
        for(int i = 0; i < k; i++)
            swap(nums, index + i, numsSize - k + i);
        //updata index and numsSize.
}

void swap(int* nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

//if nums[i] and nums[j] point to the same address, this swap is useless
// void swap(int* nums, int i, int j){
//     nums[i] = nums[i] ^ nums[j]; 
//     nums[j] = nums[i] ^ nums[j];
//     nums[i] = nums[i] ^ nums[j];
// }
```

时间复杂度O(n)，空间复杂度O(1)。

> 使用位交换的方式只有在两个元素不指向同一地址的时候使用，因此本例将swap函数进行修改。

**环状替代**

把数组想象成一个环`(index + k) % numsSize`，从数组首元素开始，每次操作将一个元素放到正确的位置，操作`n`次。

内部循环的次数与`k`和`length`的最大公约数相等。

```c
void rotate(int* nums, int numsSize, int k){
    k = k % numsSize;
    int count = 0;
    for(int index = 0; count < numsSize; index++){
        int pre = nums[index];
        int next = (index + k) % numsSize;
        int cur = nums[next];
        do{
            nums[next] = pre;
            pre = cur;
            next = (next + k) % numsSize;
            cur = nums[next];
            count++;
        }while(next != (index + k));
    }
}
```

时间复杂度O(n)，空间复杂度O(1)。较优的算法，细节上容易出错。

**数组翻转**

```c
 void Reverse(int R[], int low, int high){
   	while (low < high) {
      	L.data[low] = L.data[low] ^ L.data[high];
      	L.data[high] = L.data[low] ^ L.data[high];
        L.data[low] = L.data[low] ^ L.data[high];
      	low++;
      	high--;
    }
 }
void  Converse (int R[], int n, int p){ t
  	Reverse(R, 0, p - 1);
  	Reverse(R, p, n - 1);
  	Reverse(R, 0, n - 1);
}
```

时间复杂度O(n)，空间复杂度O(1)。算法高效且便于理解。

#### 11. 合并数组找中位数

【2011统考真题】一个长度为L(L >= 1)的升序序列S，处在第$\left \lceil L/2 \right \rceil$个位置的数称为S的中位数。例现在有两个等长的升序序列A和B，设计一个在时间和空间两方面尽可能高效的算法。

```c
  void Median(sqlList &A, sqlList &B, int n) {
			int h1 = 0, h2 = 0, e1 = n - 1, e2 = n - 1;
    	int m1, m2;
    	while(h1 != e1 || h2 != e2){
        	m1 = (h1 + e1) / 2;
        	m2 = (h2 + e2) / 2;
        	if(A[m1] = B[m1]){
            	return A[m1];
          }
        	if(A[m1] < A[m2]){
            	if((e1 - h1) % 2 == 0){
                	h1 = m1 + 1;
                	h2 = m2;
              }else{
                	h1 = m1;
                  h2 = m2;
              }
          }else{
            	if((e1 - h1) % 2 ==0){
                	h1 = m1;
                	h2 = m2 + 1;
              }else{
                	h1 = m1;
               		h2 = m2;  
              }
          }
      }
    	return A[h1] < B[h2] ? A[h1] : B[h2];
 }              
```

时间复杂度O(nlogn), 空间复杂度O(1)。

扩展：如果两个升序数组不等长，那么如何计算中位数。

创建一个新数组实现：

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int newLength = nums1.length + nums2.length;
        int[] extendNums = new int[newLength];
        int index = 0, index1 = 0, index2 = 0;
        while(index1 < nums1.length && index2 < nums2.length){
            extendNums[index++] = nums1[index1] < nums2[index2] ? nums1[index1++] : nums2[index2++];
        }
        while(index1 < nums1.length){
            extendNums[index++] = nums1[index1++];
        }
        while(index2 < nums2.length){
            extendNums[index++] = nums2[index2++];
        }
        if(newLength % 2 == 1){
            return extendNums[newLength / 2] / 1.0;
        } 
        return (extendNums[newLength / 2] + extendNums[newLength / 2 - 1]) / 2.0;
    }
}
```

时间复杂度为O(n)，空间复杂度为O(n)。

是否可以将时间复杂度优化为O(logn)？

...

#### 12. 数组中的众数

已知一个整数序列A=($a_{0},a_{1},a_{2},...a_{n}$)，其中$0\leq a_{i} \le n(0 \le i < n)$。寻找数组中的众数。众数是指在数组中出现次数大于 `⌊ n/2 ⌋` 的元素。

**C实现：**

采用**摩尔投票法**具有最佳性能。时间复杂度为O(n)，空间复杂度为O(1)。

摩尔投票算法是一种用来寻找一组元素中占多数元素的常数空间级时间复杂度的算法。

候选人从数组首开始选取，使用`major`。其中`count`用于统计当前候选人获得的票数，对数组进行遍历。

​	`count == 0`时，当前候选人的票被其余候选人全部抵消，需要重新选取候选人，设为当前遍历到的元素。

​	`count != 0`时，当前候选人的票有剩余，如果遍历到的元素与`major`相等，`count++`，票数加一，否则票数减一，`count--`。

假设数组中存在众数，在最坏情况下，所有其余候选人的票都被众数抵消，剩余的数即为我们所要的众数。

```c
int Majority(int A[], int n){
  	int major, count = 0;
  	for(int i = 0; i < n; i++){
      	if(count == 0) 
          	major = A[i];
      	count += (major == A[i] ? 1 : -1);
    }
  	//check.
  	for(count = 0, i = 0; i < n && A[i] = major; i++){
      	count++;
    }
  	return count > n / 2 ? major : -1;
}
```

**Java实现：**

**Boyer-Moore Voting **

时间复杂度O(n), 空间复杂度O(1)。

```java
class Solution {
    public int majorityElement(int[] nums) {
				int count = 0, major = 0;
      	for(int num : nums){
          	if(count == 0)
              	major = num;
          	count += major == num ? 1 : -1;
        }
      	return major;
    }
}
```

**Sort**

时间复杂度主要在数组排序上，为O(nlogn), 空间复杂度O(logn)。

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length / 2];
    }
}
```

**Hashmap**

遍历数组nums，用Hashmap统计个数字数量。时间和空间复杂度均为O(n)

```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> counts = new HashMap<>();
        for(int num : nums){
            //return the number of num stored in hashmap
            int count = counts.getOrDefault(num, 0) + 1;
            if(count > nums.length / 2)
                return num;
            counts.put(num, count); 
        }
        return -1;
    }
}
```

13. 给定一个含`n（n >= 1）`个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。

缺失的第一个正数。

**使用C语言实现**

1. 新建一个数组。使用空间换时间，数组B的下标标记数字是否出现，出现为1，未出现为0.

```c
int findMissMin(int A[], int n)
		int i, *B;
  	B = (int *)malloc(sizeof(int) * n);
  	memset(B, 0, sizeof(int) * n);
  	for(i = 0; i < n; i++){
      	if(A[i] > 0 && A[i] <= n)
          	B[A[i] - 1] = 1;
    }
  	for(i = 0; i < n; i++)	
      	if(B[i] == 0)
          	break;
  	return i + 1;
}
```

时间复杂度O(n)，空间复杂度O(n).

2. 数组原地操作，降低空间复杂度。

先遍历一次数组，将数组中小于等于0的干扰项设置为1，同时检查数组中是否存在1，如果不存在直接返回1。

第二次遍历数组，取出数组中的元素值a，将元素值对应的数组下标位置的元素设置为负数，如果元素已经是负数，证明与该下标(index)相等的元素已经出现，不进行操作。【元素值对应数组index所对应的数，出现过则将其置于负数，通过负数来判断元素是否出现】

第三次遍历检查数组中依旧为正数的位置，返回位置对应的`index + 1`。

```java
int firstMissingPositive(int* nums, int numsSize){
    bool flag = false;
    int i;
    for(i = 0; i < numsSize; i++){
        if(nums[i] == 1 && !flag)
            flag = true;
        if(nums[i] <= 0)
            nums[i] = 1;
    }
    if(!flag)
        return 1;
    for(i = 0; i < numsSize; i++){
        if(nums[i] > numsSize){
            continue;
        }else if(nums[abs(nums[i]) - 1] > 0){
            nums[abs(nums[i]) - 1] *= -1;
        }   
    }
    for(i = 0; i < numsSize; i++){
        if(nums[i] > 0)
            return i + 1;
    }
    return numsSize + 1;
}
```

时间复杂度O(n)，空间复杂度O(1)。

**使用Java实现：**

**创建新数组。**

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int[] numsCopy = new int[nums.length];
        int index;
        for(int num : nums){
            if(num > nums.length || num <= 0)
                continue;
            numsCopy[num - 1] = 1;  
        }
        for(index = 0; index < nums.length; index++){
            if(numsCopy[index] == 0)
                break;
        }
        return index + 1;
    }
}
```

**原地数组**

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        //find the element which smaller than zero and one. set to 1.
        int index;
        boolean flag = false;
        for(index = 0; index < nums.length; index++){
            if(nums[index] == 1)
                flag = true;
            if(nums[index] <= 0)
                nums[index] = 1;//set the negative element to length.
        }
        if(!flag)
            return 1;
        //make sure can access any element.
        for(index = 0; index < nums.length; index++){
            if(nums[index] > nums.length){
                continue;
            }   
            else{
                if(nums[Math.abs(nums[index]) - 1] > 0){
                    nums[Math.abs(nums[index]) - 1] *= -1;  
                }
            }
        }
        for(index = 0; index < nums.length; index++){
            if(nums[index] > 0)
                return index + 1;
        }
        return nums.length + 1;
    }
}
```

**借助Hashmap**

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        Set<Integer> map = new HashSet<>();
        for(int num : nums){
            //add to specified element if it's not already present
            map.add(num);
        }
        for(int i = 1; i <= nums.length; i++){
            //return true if contains. find the first element which hasn't add to set
            if(!map.contains(i)){
                return i;
            }
        }
        return nums.length + 1;
    }
}
```

时间和空间复杂度均为O(n)。

#### 14. 三元组最小距离

定义三元组(a, b, c)的距离D=｜a - b｜+|b - c| + |c - a|。给定3个非空整数集合$S_{1}$ 、$S_{2}$、$S_{3}$，按升序分别存储在3个数组中。请设计一个尽可能高效的算法，找出数组中未出现的最小正整数。

> 最小三元组问题。

算法思路：

> 三层暴力循环不考虑，时间复杂度过高O(l * m * n).

1. 依次取三元组中最小元素，计算距离，作为初始最短距离。

2. 假设三个三元组中最小元素分别为a, b,c， 并且a < b < c。【a, b, c 与A B C数组之间没有联系，可以是三个数组内的任何一个数】

   1. 此时我们可以分别对三个三元组进行增大操作，且题目需要得到最短距离。分别进行举例。
      1. 如果增加c，距离扩大，不可取。
      2. 如果增加b，分两种情况讨论，增加后的b依旧在a和c之间，对距离不产生影响，如果增加后的b大于c，那么距离扩大，不可取，故增加b不可取。
      3. 增加a，分三种情况，[增加后的a] < b，因为c不变， a增加，距离缩短；b<[增加后的a] < c，距离从原来的[c - a]缩短为[c - b]，因此距离缩短；[增加后的a] > c，距离从原来的[c - a]变为[a - c]，两者之间的距离需要通过计算确定【虽然增加a可能导致距离扩大，但是只有通过增大a才有让数组距离缩短的可能】。 如此循环往复，直到其中一个数组取到最大值后，依旧是三者中最小的元素截止。时间复杂度为O(l + m + n) => O(n) 空间复杂度O(1)。

   综上，为了得到最短的距离，只有通过增加a的方式才可能得到，其余两种方式不可能在原基础上得到更短的距离。

C语言完整代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int minNumber(int a, int b, int c) {
    int min = a < b ? a : b;
    return min < c ? min : c;
}

int findMinDistance(int *A, int *B, int *C, int l1, int l2, int l3) {
    int i = 0, j = 0, k = 0;
    int minNum, minTemp, minDis = INT_MAX;
    while (i < l1 && j < l2 && k < l3) {
        minTemp = (abs(A[i] - B[j]) + abs(A[i] - C[k]) + abs(B[j] - C[k]));
        //update the minDistance
        if (minDis > minTemp)
            minDis = minTemp;
        //find the min element and move to the bigger one.
        minNum = minNumber(A[i], B[j], C[k]);
        if (minNum == A[i]) {
            i++;
        } else if (minNum == B[j]) {
            j++;
        } else {
            k++;
        }
    }
    return minDis;
}

int main() {
    int A[3] = {-1, 0, 9};
    int B[4] = {-25, -10, 10, 11};
    int C[5] = {2, 9, 17, 30, 41};
    int minDis = findMinDistance(A, B, C, 3, 4, 5);
    printf("Min distance is %d \n", minDis);
}
```



